This constitutes a revisitation and audit of the EmbeddedTestFramework Project
this audit was done on 11-19-2022
Using Vivado Version: 	Vivado v2018.2 (64-bit) SW Build: 2258646 on Thu Jun 14 20:03:12 MDT 2018 IP Build: 2256618 on Thu Jun 14 22:10:49 MDT 2018
Using SDK Version: 		Release Version: 2018.2

The SystemILA Latency and Throughput c-code is found in the SDK folder of the SystemILA project directory, and refers to the Injector, the project has been specifically generated for Injector measurements. 
D:\ETF_2021\SystemILATest and D:\ETF_2021\SystemILATest\SystemILATest.sdk

The SystemILB Latency and Throughput c-code is found in the SDK folder of the SystemILB project directory, and refers to the Sampler,  the project has been specifically generated for Sampler measurements.
D:\ETF_2021\SystemILBTest and D:\ETF_2021\SystemILBTest\SystemILBTest.sdk

The Injector Utilization is found in the Injector_Characterization Project, and has been specifically generated for evaluating Injector resource Utilization.
D:\ETF_2021\Injector_Characterization

The Sampler Utilization is found in the Sampler_Characterization Project, and has been specifically generated for evaluating Sampler resource Utilization.
An initial Audit shows the IP had 1899 Slice LUTs compared to ~1650 in earlier records. The IP Status showed 2 IPs required updating. They were updated and the project
was rebuilt, resulting in Slice LUT consumption matching the earlier records. (not sure what happened there.)
D:\ETF_2021\Sampler_Characterization

******************************************************************************************
SystemILA - The project referring to the setup for the Test Vecotor Injector. (Confirmed close match to original results 11-19-2022)
******************************************************************************************

Simulation of the Injector is found through the IP Packaging utility of EmbeddedTestFramework.

SDK Code Directory: D:\ETF_2021\SystemILATest\SystemILATest.sdk\SystemILATest
Uses: SystemILATest Project
	  SystemILATest_bsp
	  SystemILATest_wrapper_hw_platform_0 (possibly uses both 0 or 1 or both, I did not try to isolate because I don't want to break anything.)
	  SystemILATest_wrapper_hw_platform_1 (possibly uses both 0 or 1 or both, I did not try to isolate because I don't want to break anything.)
	  
	  Project References:
	  SystemILATest project code refers to project SystemILATest_bps
	  SystemILATest_bsp does not appear to refer to anything in "Project References" natively				     (there is a link somewhere but for the purpose of revisiting the project, is not necessary.)
	  SystemILATest_wrapper_hw_platform_0 does not appear to refer to anything in "Project References" natively. (there is a link somewhere but for the purpose of revisiting the project, is not necessary.)
	  SystemILATest_wrapper_hw_platform_1 does not appear to refer to anything in "Project References" nateifly. (there is a link somewhere but for the purpose of revisiting the project, is not necessary.)
	  
How was the throughput measured?
	The Throughput was measured by using the C-code project SystemILATest found in the SYstemILA IP directory SDK to measure throughput.
	The define "#define TEST_THROUGHPUT" is uncommented but the TEST_LATENCY and TIMER_LATENCY remain commented.
	A self running test in the C Code runs to measure the throughput.

How was the latency measured?
	The latency was measured by using the same C-code project SystemILATest found in the SYstemILA IP directory SDK to measure throughput.
	The define "#define TEST_LATENCY" is uncommented but the TEST_THROUGHPUT and TIMER_LATENCY remain commented.
	A self running test in the C Code runs to measure the latency which is a result of an average value for each trial,
	each trial is repeated 5 times. (and each difference is printed to the log for each trial as a check.)
	A timer is cleared to and set to max value, and counts down in the c code. An interrupt services the timer final count value.
	The difference is calculated, and these differences are accumulated a "repeated" number of times (the test is repeated and an average value is found.)
	
	Notice: This c-code latency test measures the Latency of invoking the DMA handler and receiving a DMA done signal.
			and does not refer to latency measured with any interrupt signals generated in the hardware (this may or may not have been done separately.)


How was the utilization measured:
	The Injector_Characterization Project is used to determine resource utilization NOT the SystemILA test.
	
	D:\ETF_2021\Injector_Characterization
	The Injector_Characterization does NOT include the Zynq processor.
	
	The utilization is report is generated by simply running synth and implementation, and clicking on the "Report Utilization" in the implementation field in the flow navigator.
	By looking at this utilization report the IP utilization can be seen. However there are other blocks that may not be required.
	By using the Utilization tab, the utilization of only the Injector IP can be seen without the confusion of resources used by other blocks.
	
	Utiliation was generated for different sizes of Injector.
	
	Since only the utilization of the IP block itself is required, then opening up the SystemILA project in Vivado
	and navigating to implementation->report utilization


******************************************************************************************
SystemILB - The project referring to the setup for the Sampler IP (Confirmed close match to original results 11-19-2022)
******************************************************************************************
	This was measured in the same way as the Test Vector Injector. (See above, there is no reason to repeat this here.)
	FPGA: 		D:\ETF_2021\SystemILBTest
	C-Code: 	D:\ETF_2021\SystemILBTest\SystemILBTest.sdk
	
	
******************************************************************************************
Injector Characterization - The project referring to the Injector Resource Utilization (Confirmed close match to original results 11-19-2022)
******************************************************************************************	

Simulation of the Injector is found through the IP Packaging utility of EmbeddedTestFramework.

Measured by looking at utilization tab itself in vivado which provides a breakdown of resource utilization per block.
In the project report, this had been rebuilt for a variable number of FIFO depths to confirm how it scales with block RAM depth.


******************************************************************************************
Sampler Characterization - The project referring to the Sampler Resource Utilization (Confirmed close match to original results 11-19-2022)
******************************************************************************************	
Measured by looking at utilization tab itself in vivado which provides a breakdown of resource utilization per block.
In the project report, this had been rebuilt for a variable number of FIFO depths to confirm how it scales with block RAM depth.



******************************************************************************************
ILA Characterization - The project referring to the ILA Resource Utilization (Confirmed close match to original results 11-19-2022)
******************************************************************************************	
Measured by looking at utilization tab itself in vivado which provides a breakdown of resource utilization per block.
In the project report, this had been rebuilt for a variable number of depths to confirm how it scales.

******************************************************************************************
VIO Characterization - The project referring to the VIO Resource Utilization (Confirmed close match to original results 11-19-2022)
******************************************************************************************	
Measured by looking at utilization tab itself in vivado which provides a breakdown of resource utilization per block.
In the project report, this had been rebuilt for a variable number of depths to confirm how it scales.

This is a probe driven by a 32 bit output.
Notice: There are two sets of results, The results in P4 VIO_StandAlone in Resource Utilization folder accurately confirm close match ot original results 11-19-2022


******************************************************************************************
ILA Latency and Throughput - The project referring to the ILA Latency Measurement.
******************************************************************************************
This system is simply an ILA interfaced to a running binary counter.
One ILA asserts a high signal, this feeds into a rising pulse generator IP (generates a Rising pulse out)
The sampling ILA samples only on rising pulse edge, and therefore captures the count value.

A script is run in a loop 1024 times. A binary counter simply counts up at a clock frequency.
The difference in measured times (difference in tick values) is the difference in time between measurements.
This difference in time is equated to the latency.
The average value is 
(The time it takes to invoke and complete, and serve the results up to a log.)


The script is found in ETF/_docs/Graduate Project Measurement logs are in /Latency/ILA_Latency/run.tcl
Scripts in ETF/_tcl_scripts/
run_ila_latency.tcl 	: using the ILA_Latency Project. 
run_ila_throughput.tcl	: uses the ILA_Characterization project.

******************************************************************************************
VIO Latency and Throughput - The project referring to the VIO Latency and Measurement.
******************************************************************************************
Results found in 
Scripts in ETF/_tcl_scripts/
run_vio_latency_and_throughput.tcl
Uses the VIO_Latency project.

uses run_vio_latency_and_throughput.tcl script.
This script clears a counter, enables it, then disables it. 
The value of the counter is the time elapsed since enabling it, and disabling it.
And the latency can be inferred from that.

This script needed to be restructured (there are newlines in the script that were done for formatting purposes, but violate syntax.)
Restoring the lines to their intended form will allow the script to run.


******************************************************************************************
Simulations and/or Bench Test Verification
******************************************************************************************
I don't see simulations in the individual IP when opened with the packager 
(although it does run some type of simulation but don't see any stimulus signals there are no tcl scripts. There might be some tcl scripts somewhere
that initiated the simulation axi transactions.)

The Whole Project EmbeddedTestFramework has self tests but does not appear to have individual IP tests or simulations.
Verification was done on the Bench using ILA, the results of which are in the original Project Report.

Essential: 
	TestMultiReg :    A project with a clock divider IP, Sampler IP, injector IP, Trigger IP, and an interrupt generator. Seems to measure latency of IP under different clocking conditions.
	ILA_ClockDivider: A project that verifies the clock divider IP.   There is NO simulation available through IP Packager.
	ILA_Interrupt:    A project that verifies the Interrupt IP. ILA Is used along with SDK c-code to verify Functionality of interrupt IP. There is NO simulation available through IP Packager.
	ILA_Trigger:      A project that verifies the Trigger IP. ILA Is used along with SDK c-code to verify Functionality of interrupt IP. Also a simulation_tb is available through IP Packager from EmbeddedTestFramework Project.

Other: (Projects that may perform some verification of the VGA IP.)
	VGA_FIFO	- Deprecated and not ported Appears to be a small system for VGA discovery using AXI fifo and video timing controller (seems to be IP from xilinx.)
	VGABuffer	- Deprecated, doesn't appear to do anything on its own. (appears to be an abandoned project.)
	VGAHardware - Deprecated, doesn't appear to do anything on its own. (appears to be an abandoned project.)
	VGALineBuffer - Deprecated, doesn't appear to do anything on its own. (appears to be an abandoned project.)
	
	The VGA subsection uses Video Timing Controller and some glue logic for basic line blanking and horizontal and vertical signals. A Block ram is used as a line buffer.
	There is nothing remarkable or unique that I have done with this. (not using injector to feed anything, or anything like that... it seems we're just
	sending data to a block ram controller and the glue logic handles the rest.)







